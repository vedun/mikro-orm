"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[3431],{3905:function(e,t,n){n.d(t,{Zo:function(){return m},kt:function(){return c}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function o(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function i(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?o(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):o(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},o=Object.keys(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var o=Object.getOwnPropertySymbols(e);for(a=0;a<o.length;a++)n=o[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var l=a.createContext({}),p=function(e){var t=a.useContext(l),n=t;return e&&(n="function"==typeof e?e(t):i(i({},t),e)),n},m=function(e){var t=p(e.components);return a.createElement(l.Provider,{value:t},e.children)},u={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,o=e.originalType,l=e.parentName,m=s(e,["components","mdxType","originalType","parentName"]),d=p(n),c=r,h=d["".concat(l,".").concat(c)]||d[c]||u[c]||o;return n?a.createElement(h,i(i({ref:t},m),{},{components:n})):a.createElement(h,i({ref:t},m))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var o=n.length,i=new Array(o);i[0]=d;var s={};for(var l in t)hasOwnProperty.call(t,l)&&(s[l]=t[l]);s.originalType=e,s.mdxType="string"==typeof e?e:r,i[1]=s;for(var p=2;p<o;p++)i[p]=n[p];return a.createElement.apply(null,i)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},76061:function(e,t,n){n.r(t),n.d(t,{assets:function(){return m},contentTitle:function(){return l},default:function(){return c},frontMatter:function(){return s},metadata:function(){return p},toc:function(){return u}});var a=n(83117),r=n(80102),o=(n(67294),n(3905)),i=["components"],s={slug:"mikro-orm-3-released",title:"MikroORM 3: Knex.js, CLI, Schema Updates, Entity Generator and\xa0more\u2026",author:"Martin Ad\xe1mek",authorTitle:"Author of MikroORM",authorURL:"https://github.com/B4nan",authorImageURL:"https://avatars1.githubusercontent.com/u/615580?s=460&v=4",authorTwitter:"B4nan",tags:["typescript","javascript","node","sql"]},l=void 0,p={permalink:"/blog/mikro-orm-3-released",source:"@site/blog/2020-01-16-mikro-orm-3-released.md",title:"MikroORM 3: Knex.js, CLI, Schema Updates, Entity Generator and\xa0more\u2026",description:"New major version of the TypeScript ORM has been released, read about its new features and breaking changes.",date:"2020-01-16T00:00:00.000Z",formattedDate:"January 16, 2020",tags:[{label:"typescript",permalink:"/blog/tags/typescript"},{label:"javascript",permalink:"/blog/tags/javascript"},{label:"node",permalink:"/blog/tags/node"},{label:"sql",permalink:"/blog/tags/sql"}],readingTime:10.52,hasTruncateMarker:!0,authors:[{name:"Martin Ad\xe1mek",title:"Author of MikroORM",url:"https://github.com/B4nan",imageURL:"https://avatars1.githubusercontent.com/u/615580?s=460&v=4"}],frontMatter:{slug:"mikro-orm-3-released",title:"MikroORM 3: Knex.js, CLI, Schema Updates, Entity Generator and\xa0more\u2026",author:"Martin Ad\xe1mek",authorTitle:"Author of MikroORM",authorURL:"https://github.com/B4nan",authorImageURL:"https://avatars1.githubusercontent.com/u/615580?s=460&v=4",authorTwitter:"B4nan",tags:["typescript","javascript","node","sql"]},prevItem:{title:"MikroORM 4: Filling the Gaps",permalink:"/blog/mikro-orm-4-released"},nextItem:{title:"Handling Transactions and Concurrency in MikroORM",permalink:"/blog/handling-transactions-and-concurrency-in-mikroorm"}},m={authorsImageUrls:[void 0]},u=[{value:"In case you don\u2019t know\u2026",id:"in-case-you-dont-know",level:3},{value:"Integrated Knex.js",id:"integrated-knexjs",level:3},{value:"Using Knex.js",id:"using-knexjs",level:4},{value:"Connection Pooling",id:"connection-pooling",level:4},{value:"More SQL Drivers?",id:"more-sql-drivers",level:4},{value:"Simplified Entity Definition",id:"simplified-entity-definition",level:3},{value:"Nested Queries",id:"nested-queries",level:3},{value:"Strict Typing of Queries",id:"strict-typing-of-queries",level:3},{value:"Improved Schema Generator",id:"improved-schema-generator",level:3},{value:"Migrations",id:"migrations",level:3},{value:"Generating Entities from Current Database",id:"generating-entities-from-current-database",level:3},{value:"CLI",id:"cli",level:3},{value:"Custom Mapping Types",id:"custom-mapping-types",level:3},{value:"And Many More\u2026",id:"and-many-more",level:3},{value:"Notable Breaking Changes",id:"notable-breaking-changes",level:3},{value:"Auto-flushing Disabled by Default",id:"auto-flushing-disabled-by-default",level:4},{value:"Transactions API",id:"transactions-api",level:4},{value:"Making it a bit more Professional\u2026",id:"making-it-a-bit-more-professional",level:3},{value:"What\u2019s next?",id:"whats-next",level:3},{value:"WDYT?",id:"wdyt",level:4}],d={toc:u};function c(e){var t=e.components,n=(0,r.Z)(e,i);return(0,o.kt)("wrapper",(0,a.Z)({},d,n,{components:t,mdxType:"MDXLayout"}),(0,o.kt)("p",null,"New major version of the TypeScript ORM has been released, read about its new features and breaking changes."),(0,o.kt)("h3",{id:"in-case-you-dont-know"},"In case you don\u2019t know\u2026"),(0,o.kt)("p",null,"If you never heard of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm"},"MikroORM"),", it\u2019s a TypeScript data-mapper ORM with Unit of Work and Identity Map. It supports MongoDB, MySQL, PostgreSQL and SQLite drivers currently. Key features of the ORM are:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/mikro-orm/mikro-orm#implicit-transactions"},"Implicit transactions")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://github.com/mikro-orm/mikro-orm#changeset-based-persistence"},"ChangeSet based persistence")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/identity-map/"},"Identity map"))),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/1024/0*0eZmw4DceSltEEQh.png",alt:null})),(0,o.kt)("p",null,"You can read the full ",(0,o.kt)("a",{parentName:"p",href:"https://medium.com/dailyjs/introducing-mikro-orm-typescript-data-mapper-orm-with-identity-map-9ba58d049e02"},"introductory article here")," or ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io"},"browse through the docs"),"."),(0,o.kt)("h3",{id:"integrated-knexjs"},"Integrated Knex.js"),(0,o.kt)("p",null,"You probably know Knex.js already, but if you don\u2019t, it is a \u201cbatteries included\u201d SQL query builder for ",(0,o.kt)("strong",{parentName:"p"},"Postgres")," , ",(0,o.kt)("strong",{parentName:"p"},"MSSQL")," , ",(0,o.kt)("strong",{parentName:"p"},"MySQL")," , ",(0,o.kt)("strong",{parentName:"p"},"MariaDB")," , ",(0,o.kt)("strong",{parentName:"p"},"SQLite3")," , ",(0,o.kt)("strong",{parentName:"p"},"Oracle")," , and ",(0,o.kt)("strong",{parentName:"p"},"Amazon Redshift")," designed to be flexible, portable, and fun to use."),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/649/0*FHWIwC9WTwl2hkQ7.png",alt:null})),(0,o.kt)("p",null,"Knex.js is now used as both a query builder and a query runner for all SQL drivers. This allows to simplify SQL driver implementations as well as brings some new possibilities."),(0,o.kt)("h4",{id:"using-knexjs"},"Using Knex.js"),(0,o.kt)("p",null,"You can access configured knex instance via qb.getKnexQuery() method. Then you can execute it via the Connection.execute() and map the results via EntityManager.map()."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const qb = orm.em.createQueryBuilder(Author);\nqb.update({ name: 'test 123', type: PublisherType.GLOBAL }).where({ id: 123, type: PublisherType.LOCAL });\nconst knex = qb.getKnexQuery(); // instance of Knex' QueryBuilder\n// do what ever you need with `knex`\nconst res = await orm.em.getConnection().execute(knex);\nconst entities = res.map(a => orm.em.map(Author, a));\nconsole.log(entities); // Author[]\n")),(0,o.kt)("p",null,"You can also get clear and configured knex instance from the connection via getKnex() method. As this method is not available on the base Connection class, you will need to either manually type cast the connection to AbstractSqlConnection (or the actual implementation you are using, e.g. MySqlConnection), or provide correct driver type hint to your EntityManager instance, which will be then automatically inferred in em.getConnection() method."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Driver and connection implementations are not directly exported from mikro-orm module. You can import them from mikro-orm/dist (e.g. import { PostgreSqlDriver } from 'mikro-orm/dist/drivers/PostgreSqlDriver').")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const conn = orm.em.getConnection() as AbstractSqlConnection;\n// you can make sure the `em` is correctly typed to `EntityManager<AbstractSqlDriver>`\n// or one of its implementations:\n// const em: EntityManager<AbstractSqlDriver> = orm.em;\nconst knex = conn.getKnex();\n// do what ever you need with `knex`\nconst res = await knex;\n")),(0,o.kt)("h4",{id:"connection-pooling"},"Connection Pooling"),(0,o.kt)("p",null,"With Knex.js used as a query runner, support for connection pooling is finally available. ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/vincit/tarn.js"},"Tarn.js")," is used for this internally, using connection pool with min: 2, max: 10 for the MySQL and PG libraries, and a single connection for sqlite3 by default. Use pool option to change this when initializing the ORM."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const orm = await MikroORM.init({\n  entities: [Author, Book],\n  dbName: 'my-db-name',\n  pool: { min: 10, max: 20 }, // see https://github.com/vincit/tarn.js#usage for other pool options\n});\n")),(0,o.kt)("h4",{id:"more-sql-drivers"},"More SQL Drivers?"),(0,o.kt)("p",null,"One of the strongest reasons to integrate Knex.js was that it allows to simplify and unify SQL drivers and opens doors for implementing new SQL drivers. Knex.js currently supports (apart from those currently supported by MikroORM): MSSQL, Oracle and Amazon Redshift."),(0,o.kt)("p",null,"Thanks to AbstractSqlDriver and AbstractSqlConnection classes it should be fairly simple to implement them. I am open for PRs for those drivers, as I would like to focus on developing new ORM features mainly, instead of learning new SQL dialects I have never used. I will be happy to assist to anybody interested\u200a\u2014\u200afeel free to reach me out either via Slack, email or GitHub issues."),(0,o.kt)("h3",{id:"simplified-entity-definition"},"Simplified Entity Definition"),(0,o.kt)("p",null,"Now it is no longer needed to merge entities with IEntity interface, that was polluting entity's interface with internal methods. New interfaces IdentifiedEntity\\<T",">",", UuidEntity\\<T",">"," and MongoEntity\\<T",">"," are introduced, that should be implemented by entities. They are not adding any new properties or methods, keeping the entity's interface clean."),(0,o.kt)("p",null,"IEntity interface has been renamed to AnyEntity\\<T, PK",">"," and it no longer has public methods like toJSON(), toObject() or init(). One can use wrap() method provided by ORM that will enhance property type when needed with those methods (e.g. await wrap(book.author).init()). To keep all methods available on the entity, you can still use interface merging with WrappedEntity\\<T, PK",">"," that both extends AnyEntity\\<T, PK",">"," and defines all those methods."),(0,o.kt)("p",null,"You will need to mark the entity by implementing one of ","*","Entity interfaces:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"IdEntity\\<T",">"," for numeric/string PK on id property (id: number)"),(0,o.kt)("li",{parentName:"ul"},"UuidEntity\\<T",">"," for string PK on uuid property (uuid: string)"),(0,o.kt)("li",{parentName:"ul"},"MongoEntity\\<T",">"," for mongo, where id: string and ","_","id: ObjectId are required"),(0,o.kt)("li",{parentName:"ul"},"AnyEntity\\<T, PK",">"," for other possible properties (fill the PK property name to PK parameter, e.g.: AnyEntity\\<Book, 'myPrimaryProperty'",">","')")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Entity()\nexport class User implements IdEntity<User> {\n\n  @PrimaryKey()\n  id!: number;\n\n  @Property()\n  name!: string;\n\n  @OneToOne()\n  address?: Address;\n\n  @ManyToMany()\n  cars = new Collection<Car>(this);\n\n  constructor(name: string) {\n    this.name = name;\n  }\n\n}\n")),(0,o.kt)("p",null,"To keep all public methods that were part of IEntity interface in v2, you can use ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/defining-entities#using-wrappedentity-interface"},"WrappedEntity\\<T, PK",">"," via interface merging"),"."),(0,o.kt)("h3",{id:"nested-queries"},"Nested Queries"),(0,o.kt)("p",null,"SQL driver now support nested where and orderBy conditions. This means that you can query by properties of a relationship and the relation will be automatically joined for you. They are available both in EntityManager and QueryBuilder APIs."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"const book = await orm.em.findOne(Book, {\n  author: {\n    name: 'Jon Snow',\n    address: {\n      street: 'Downing Street',\n    },\n  },\n}, ['author.address']);\n\nconsole.log(book.author.name); // 'Jon Snow'\nconsole.log(book.author.address.street); // 'Downing Street'\n")),(0,o.kt)("h3",{id:"strict-typing-of-queries"},"Strict Typing of Queries"),(0,o.kt)("p",null,"Previously the where parameter of EntityManager\u2019s find methods (find(), findOne(), count()) was weakly typed. It allowed users to pass pretty much anything there."),(0,o.kt)("p",null,"Now the query is strictly typed, only entity properties and operators can be used and the type of property value is also checked."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"// correct query\nem.find(Author, {\n  favouriteBook: {\n    author: { name: '...' },\n  },\n  age: { $gte: 40 }, // operators are also supported\n});\n\n// 2 errors will be reported here\nem.find(Author, {\n  favouriteBook: {\n    author: { born: 'test' }, // string instead of Date\n  },\n  age: { $lte: 'nan' }, // string instead of number\n});\n")),(0,o.kt)("h3",{id:"improved-schema-generator"},"Improved Schema Generator"),(0,o.kt)("p",null,"SchemaGenerator now supports creating, updating and dropping the schema. You can either get the SQL queries as array of strings or directly run them on the database."),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},"Always check the generated SQL first before running it.")),(0,o.kt)("p",null,"There is also new columnType property attribute you can use to specify the database specific column type explicitly."),(0,o.kt)("h3",{id:"migrations"},"Migrations"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/628/0*b3RWZY_ROCrJs3RE.jpeg",alt:null})),(0,o.kt)("p",null,"Better way to handle schema updates than using the SchemaGenerator directly is to use Migrations. MikroORM 3 has ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/migrations"},"integrated support for migrations")," via ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/sequelize/umzug"},"umzug"),". It allows you to generate migrations with current schema differences."),(0,o.kt)("p",null,"By default, each migration will be all executed inside a transaction, and all of them will be wrapped in one master transaction, so if one of them fails, everything will be rolled back."),(0,o.kt)("h3",{id:"generating-entities-from-current-database"},"Generating Entities from Current Database"),(0,o.kt)("p",null,"As a counterpart to the SchemaGenerator that propagates changes in your entities to the database schema, there is now ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/entity-generator"},"EntityGenerator")," to help you with reverse engineering current database schema and creating entities based on it."),(0,o.kt)("p",null,"It supports basic entity definition including ManyToOne and OneToOne relationships. Currently ManyToMany will be generated as additional entity with two ManyToOne relations and you will need to refactor this yourself."),(0,o.kt)("p",null,"While it can help a lot, there is quite a lot of room for improvement. In future I would like to implement proper support for ManyToMany relations as well for enums and indexes. Another possible extension would be to allow editing existing entities (syncing them with current schema)."),(0,o.kt)("h3",{id:"cli"},"CLI"),(0,o.kt)("p",null,"While you can use SchemaGenerator and EntityGenerator manually, much easier way is to use ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/installation#setting-up-the-commandline-tool"},"new CLI tool"),". Simply create configuration file in root directory or add its path to package.json. TypeScript files are also supported via ts-node:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-json"},'{\n  "name": "your-app",\n  "dependencies": { ... },\n  "mikro-orm": {\n    "useTsNode": true,\n    "configPaths": [\n      "./src/mikro-orm.config.ts",\n      "./dist/mikro-orm.config.js"\n    ]\n  }\n}\n')),(0,o.kt)("p",null,"Now you can use the CLI with help of ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/npm/npx"},"npx"),":"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-sh"},"$ npx mikro-orm\nUsage: mikro-orm <command> [options]\n\nCommands:\n  mikro-orm cache:clear             Clear metadata cache\n  mikro-orm cache:generate          Generate metadata cache for production\n  mikro-orm generate-entities       Generate entities based on current database\n                                    schema\n  mikro-orm database:import <file>  Imports the SQL file to the database\n  mikro-orm schema:create           Create database schema based on current\n                                    metadata\n  mikro-orm schema:drop             Drop database schema based on current\n                                    metadata\n  mikro-orm schema:update           Update database schema based on current\n                                    metadata\n  mikro-orm migration:create        Create new migration with current schema\n                                    diff\n  mikro-orm migration:up            Migrate up to the latest version\n  mikro-orm migration:down          Migrate one step down\n  mikro-orm migration:list          List all executed migrations\n  mikro-orm migration:pending       List all pending migrations\n  mikro-orm debug                   Debug CLI configuration\n\nOptions:\n  -v, --version  Show version number                                   [boolean]\n  -h, --help     Show help                                             [boolean]\n\nExamples:\n  mikro-orm schema:update --run  Runs schema synchronization\n")),(0,o.kt)("p",null,"To verify your setup, you can use the mikro-orm debug command. Once you have it configured properly, you can also re-use it when initializing the ORM:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre"},"// when no options parameter is provided, CLI config will be used\nconst orm = await MikroORM.init();\n")),(0,o.kt)("h3",{id:"custom-mapping-types"},"Custom Mapping Types"),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/500/0*zAn0BtH_iz7b8Ywj.jpg",alt:null})),(0,o.kt)("p",null,"With ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/custom-types/"},"Custom Types")," we can now enhance how the database value will be represented in the ORM. You can define custom types by extending Type abstract class, it has 4 optional methods:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"convertToDatabaseValue(value: any, platform: Platform): any")),(0,o.kt)("p",null,"Converts a value from its JS representation to its database representation of this type. By default returns unchanged value."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"convertToJSValue(value: any, platform: Platform): any")),(0,o.kt)("p",null,"Converts a value from its database representation to its JS representation of this type. By default returns unchanged value."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"toJSON(value: any, platform: Platform): any")),(0,o.kt)("p",null,"Converts a value from its JS representation to its serialized JSON form of this type. By default converts to the database value."),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"getColumnType(prop: EntityProperty, platform: Platform): string")),(0,o.kt)("p",null,"Gets the SQL declaration snippet for a field of this type. By default returns columnType of given property."),(0,o.kt)("p",null,"Here is a simplified version of DateType that is already present in the ORM:"),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"import { Type, Platform, EntityProperty, ValidationError } from 'mikro-orm';\n\nexport class DateType extends Type {\n\n  convertToDatabaseValue(value: any, platform: Platform): any {\n    return value.toISOString().substr(0, 10);\n  }\n\n  convertToJSValue(value: any, platform: Platform): any {\n    return new Date(value);\n  }\n\n  getColumnType(): string {\n    return 'date';\n  }\n\n}\n")),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"@Entity()\nexport class FooBar implements IdEntity<FooBar> {\n  \n  @PrimaryKey()\n  id!: number;\n  \n  @Property({ type: DateType })\n  born?: Date;\n\n}\n")),(0,o.kt)("h3",{id:"and-many-more"},"And Many More\u2026"),(0,o.kt)("p",null,"There are many more new features, see the ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm/blob/master/CHANGELOG.md"},"changelog")," to read the full list. Here are few of them worth mentioning:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/entity-references/"},"Improved support for References")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/defining-entities/#enums"},"Navite Enum support")),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/entity-manager#fetching-paginated-results"},"em.findAndCount()")," and ",(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/entity-manager#handling-not-found-entities"},"em.findOneOrFail()")," methods"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/metadata-providers/#reflectmetadataprovider"},"ReflectMetadataProvider")," as a fast alternative to ts-morph reflection"),(0,o.kt)("li",{parentName:"ul"},"Improved logging with query highlighting"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/deployment/#deploy-a-bundle-of-entities-and-dependencies-with-webpack"},"Support for bundling via Webpack")),(0,o.kt)("li",{parentName:"ul"},"Eager loading"),(0,o.kt)("li",{parentName:"ul"},(0,o.kt)("a",{parentName:"li",href:"https://mikro-orm.io/docs/read-connections"},"Read Connections")),(0,o.kt)("li",{parentName:"ul"},"More strict entity definition validation")),(0,o.kt)("h3",{id:"notable-breaking-changes"},"Notable Breaking Changes"),(0,o.kt)("p",null,"Here is a short list of breaking changes. You can see the full list in the docs: ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/docs/upgrading-v2-to-v3/"},"https://mikro-orm.io/docs/upgrading-v2-to-v3/"),"."),(0,o.kt)("h4",{id:"auto-flushing-disabled-by-default"},"Auto-flushing Disabled by Default"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"If you had")," ",(0,o.kt)("em",{parentName:"p"},"autoFlush: false in your ORM configuration before, you can now remove this line, no changes are needed in your app."))),(0,o.kt)("p",null,"Default value for autoFlush is now false. That means you need to call em.flush() yourself to persist changes into database. You can still change this via ORM's options to ease the transition but generally it is not recommended as it can cause unwanted small transactions being created around each persist."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"orm.em.persist(new Entity()); // no auto-flushing by default\nawait orm.em.flush();\nawait orm.em.persist(new Entity(), true); // you can still use second parameter to auto-flush\n")),(0,o.kt)("h4",{id:"transactions-api"},"Transactions API"),(0,o.kt)("p",null,"Transactions now require using em.transactional() method, previous methods beginTransaction/commit/rollback are now removed."),(0,o.kt)("pre",null,(0,o.kt)("code",{parentName:"pre",className:"language-typescript"},"await orm.em.transactional(async _em => {\n  //... do some work\n  const user = new User(...);\n  user.name = 'George';\n  _em.persistLater(user);\n});\n")),(0,o.kt)("h3",{id:"making-it-a-bit-more-professional"},"Making it a bit more Professional\u2026"),(0,o.kt)("p",null,"Not a big deal, but probably worth mentioning\u200a\u2014\u200aMikroORM\u2019s repository has been transferred to new ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm"},"MikroORM GitHub Organization")," and the website is now moved to ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io"},"mikro-orm.io"),". Old links should be properly redirected, if you find some 404, please let me know thru GitHub issues!"),(0,o.kt)("p",null,"Website has also been redesigned\u200a\u2014\u200anow it is built with Docusaurus (v2) and provides fulltext search by Algolia. The docs are now also ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io/versions"},"versioned"),"."),(0,o.kt)("p",null,(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io"},"Check it out!")),(0,o.kt)("p",null,(0,o.kt)("img",{parentName:"p",src:"https://cdn-images-1.medium.com/max/1024/1*2pdwLgyPZNltJQ_2j8poSQ.png",alt:null})),(0,o.kt)("h3",{id:"whats-next"},"What\u2019s next?"),(0,o.kt)("p",null,"Here are some features I am planning to work in the near future:"),(0,o.kt)("ul",null,(0,o.kt)("li",{parentName:"ul"},"Composite primary keys"),(0,o.kt)("li",{parentName:"ul"},"Transactions in MongoDB"),(0,o.kt)("li",{parentName:"ul"},"Complex hydration of joined result sets"),(0,o.kt)("li",{parentName:"ul"},"Slow query log"),(0,o.kt)("li",{parentName:"ul"},"M:N support in entity generator")),(0,o.kt)("p",null,"There are also some interesting suggestion in the Github issues, like ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm/issues/266"},"Dataloader integration"),"."),(0,o.kt)("h4",{id:"wdyt"},"WDYT?"),(0,o.kt)("p",null,"So that is MikroORM 3, what do you think about it? What features or changes would you like to see next? Or what part of the documentation should be improved and how?"),(0,o.kt)("blockquote",null,(0,o.kt)("p",{parentName:"blockquote"},(0,o.kt)("em",{parentName:"p"},"Like")," ",(0,o.kt)("a",{parentName:"p",href:"https://mikro-orm.io"},(0,o.kt)("em",{parentName:"a"},"MikroORM")),(0,o.kt)("em",{parentName:"p"},"? \u2b50\ufe0f")," ",(0,o.kt)("a",{parentName:"p",href:"https://github.com/mikro-orm/mikro-orm"},(0,o.kt)("em",{parentName:"a"},"Star it"))," ",(0,o.kt)("em",{parentName:"p"},"on GitHub and share this article with your friends."))),(0,o.kt)("hr",null))}c.isMDXComponent=!0}}]);