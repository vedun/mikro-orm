"use strict";(self.webpackChunkdocs=self.webpackChunkdocs||[]).push([[1554],{3905:function(e,t,n){n.d(t,{Zo:function(){return p},kt:function(){return c}});var a=n(67294);function r(e,t,n){return t in e?Object.defineProperty(e,t,{value:n,enumerable:!0,configurable:!0,writable:!0}):e[t]=n,e}function i(e,t){var n=Object.keys(e);if(Object.getOwnPropertySymbols){var a=Object.getOwnPropertySymbols(e);t&&(a=a.filter((function(t){return Object.getOwnPropertyDescriptor(e,t).enumerable}))),n.push.apply(n,a)}return n}function l(e){for(var t=1;t<arguments.length;t++){var n=null!=arguments[t]?arguments[t]:{};t%2?i(Object(n),!0).forEach((function(t){r(e,t,n[t])})):Object.getOwnPropertyDescriptors?Object.defineProperties(e,Object.getOwnPropertyDescriptors(n)):i(Object(n)).forEach((function(t){Object.defineProperty(e,t,Object.getOwnPropertyDescriptor(n,t))}))}return e}function s(e,t){if(null==e)return{};var n,a,r=function(e,t){if(null==e)return{};var n,a,r={},i=Object.keys(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||(r[n]=e[n]);return r}(e,t);if(Object.getOwnPropertySymbols){var i=Object.getOwnPropertySymbols(e);for(a=0;a<i.length;a++)n=i[a],t.indexOf(n)>=0||Object.prototype.propertyIsEnumerable.call(e,n)&&(r[n]=e[n])}return r}var o=a.createContext({}),u=function(e){var t=a.useContext(o),n=t;return e&&(n="function"==typeof e?e(t):l(l({},t),e)),n},p=function(e){var t=u(e.components);return a.createElement(o.Provider,{value:t},e.children)},m={inlineCode:"code",wrapper:function(e){var t=e.children;return a.createElement(a.Fragment,{},t)}},d=a.forwardRef((function(e,t){var n=e.components,r=e.mdxType,i=e.originalType,o=e.parentName,p=s(e,["components","mdxType","originalType","parentName"]),d=u(n),c=r,y=d["".concat(o,".").concat(c)]||d[c]||m[c]||i;return n?a.createElement(y,l(l({ref:t},p),{},{components:n})):a.createElement(y,l({ref:t},p))}));function c(e,t){var n=arguments,r=t&&t.mdxType;if("string"==typeof e||r){var i=n.length,l=new Array(i);l[0]=d;var s={};for(var o in t)hasOwnProperty.call(t,o)&&(s[o]=t[o]);s.originalType=e,s.mdxType="string"==typeof e?e:r,l[1]=s;for(var u=2;u<i;u++)l[u]=n[u];return a.createElement.apply(null,l)}return a.createElement.apply(null,n)}d.displayName="MDXCreateElement"},85162:function(e,t,n){n.d(t,{Z:function(){return l}});var a=n(67294),r=n(86010),i="tabItem_Ymn6";function l(e){var t=e.children,n=e.hidden,l=e.className;return a.createElement("div",{role:"tabpanel",className:(0,r.Z)(i,l),hidden:n},t)}},65488:function(e,t,n){n.d(t,{Z:function(){return c}});var a=n(83117),r=n(67294),i=n(86010),l=n(72389),s=n(67392),o=n(7094),u=n(12466),p="tabList__CuJ",m="tabItem_LNqP";function d(e){var t,n,l=e.lazy,d=e.block,c=e.defaultValue,y=e.values,h=e.groupId,k=e.className,f=r.Children.map(e.children,(function(e){if((0,r.isValidElement)(e)&&"value"in e.props)return e;throw new Error("Docusaurus error: Bad <Tabs> child <"+("string"==typeof e.type?e.type:e.type.name)+'>: all children of the <Tabs> component should be <TabItem>, and every <TabItem> should have a unique "value" prop.')})),g=null!=y?y:f.map((function(e){var t=e.props;return{value:t.value,label:t.label,attributes:t.attributes}})),b=(0,s.l)(g,(function(e,t){return e.value===t.value}));if(b.length>0)throw new Error('Docusaurus error: Duplicate values "'+b.map((function(e){return e.value})).join(", ")+'" found in <Tabs>. Every value needs to be unique.');var v=null===c?c:null!=(t=null!=c?c:null==(n=f.find((function(e){return e.props.default})))?void 0:n.props.value)?t:f[0].props.value;if(null!==v&&!g.some((function(e){return e.value===v})))throw new Error('Docusaurus error: The <Tabs> has a defaultValue "'+v+'" but none of its children has the corresponding value. Available values are: '+g.map((function(e){return e.value})).join(", ")+". If you intend to show no default tab, use defaultValue={null} instead.");var N=(0,o.U)(),x=N.tabGroupChoices,T=N.setTabGroupChoices,w=(0,r.useState)(v),E=w[0],B=w[1],I=[],C=(0,u.o5)().blockElementScrollPositionUntilNextRender;if(null!=h){var P=x[h];null!=P&&P!==E&&g.some((function(e){return e.value===P}))&&B(P)}var A=function(e){var t=e.currentTarget,n=I.indexOf(t),a=g[n].value;a!==E&&(C(t),B(a),null!=h&&T(h,String(a)))},S=function(e){var t,n=null;switch(e.key){case"ArrowRight":var a,r=I.indexOf(e.currentTarget)+1;n=null!=(a=I[r])?a:I[0];break;case"ArrowLeft":var i,l=I.indexOf(e.currentTarget)-1;n=null!=(i=I[l])?i:I[I.length-1]}null==(t=n)||t.focus()};return r.createElement("div",{className:(0,i.Z)("tabs-container",p)},r.createElement("ul",{role:"tablist","aria-orientation":"horizontal",className:(0,i.Z)("tabs",{"tabs--block":d},k)},g.map((function(e){var t=e.value,n=e.label,l=e.attributes;return r.createElement("li",(0,a.Z)({role:"tab",tabIndex:E===t?0:-1,"aria-selected":E===t,key:t,ref:function(e){return I.push(e)},onKeyDown:S,onFocus:A,onClick:A},l,{className:(0,i.Z)("tabs__item",m,null==l?void 0:l.className,{"tabs__item--active":E===t})}),null!=n?n:t)}))),l?(0,r.cloneElement)(f.filter((function(e){return e.props.value===E}))[0],{className:"margin-top--md"}):r.createElement("div",{className:"margin-top--md"},f.map((function(e,t){return(0,r.cloneElement)(e,{key:t,hidden:e.props.value!==E})}))))}function c(e){var t=(0,l.Z)();return r.createElement(d,(0,a.Z)({key:String(t)},e))}},73185:function(e,t,n){n.r(t),n.d(t,{assets:function(){return d},contentTitle:function(){return p},default:function(){return h},frontMatter:function(){return u},metadata:function(){return m},toc:function(){return c}});var a=n(83117),r=n(80102),i=(n(67294),n(3905)),l=n(65488),s=n(85162),o=["components"],u={title:"Defining Entities"},p=void 0,m={unversionedId:"defining-entities",id:"defining-entities",title:"Defining Entities",description:"Entities are simple javascript objects (so called POJO) without restrictions and without the need to extend base classes. Using entity constructors works as well - they are never executed for managed entities (loaded from database).",source:"@site/docs/defining-entities.md",sourceDirName:".",slug:"/defining-entities",permalink:"/docs/next/defining-entities",draft:!1,editUrl:"https://github.com/mikro-orm/mikro-orm/edit/master/docs/docs/defining-entities.md",tags:[],version:"current",lastUpdatedBy:"Martin Ad\xe1mek",lastUpdatedAt:1658864842,formattedLastUpdatedAt:"Jul 26, 2022",frontMatter:{title:"Defining Entities"},sidebar:"docs",previous:{title:"Installation & Usage",permalink:"/docs/next/installation"},next:{title:"Modeling Entity Relationships",permalink:"/docs/next/relationships"}},d={},c=[{value:"Optional Properties",id:"optional-properties",level:2},{value:"Default values",id:"default-values",level:2},{value:"Enums",id:"enums",level:2},{value:"Enum arrays",id:"enum-arrays",level:2},{value:"Mapping directly to primary keys",id:"mapping-directly-to-primary-keys",level:2},{value:"Formulas",id:"formulas",level:2},{value:"Indexes",id:"indexes",level:2},{value:"Check constraints",id:"check-constraints",level:2},{value:"Custom Types",id:"custom-types",level:2},{value:"Lazy scalar properties",id:"lazy-scalar-properties",level:2},{value:"Virtual Properties",id:"virtual-properties",level:2},{value:"Entity file names",id:"entity-file-names",level:2},{value:"Using custom base entity",id:"using-custom-base-entity",level:2},{value:"Examples of entity definition with various primary keys",id:"examples-of-entity-definition-with-various-primary-keys",level:2},{value:"Using id as primary key (SQL drivers)",id:"using-id-as-primary-key-sql-drivers",level:3},{value:"Using UUID as primary key (SQL drivers)",id:"using-uuid-as-primary-key-sql-drivers",level:3},{value:"Using PostgreSQL uuid-osp module function as primary key",id:"using-postgresql-uuid-osp-module-function-as-primary-key",level:3},{value:"Using BigInt as primary key (MySQL and PostgreSQL)",id:"using-bigint-as-primary-key-mysql-and-postgresql",level:3},{value:"Example of Mongo entity",id:"example-of-mongo-entity",level:3},{value:"Using MikroORM&#39;s BaseEntity (previously WrappedEntity)",id:"using-mikroorms-baseentity-previously-wrappedentity",level:3}],y={toc:c};function h(e){var t=e.components,n=(0,r.Z)(e,o);return(0,i.kt)("wrapper",(0,a.Z)({},y,n,{components:t,mdxType:"MDXLayout"}),(0,i.kt)("p",null,"Entities are simple javascript objects (so called POJO) without restrictions and without the need to extend base classes. Using ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/entity-constructors"},"entity constructors")," works as well - they are never executed for managed entities (loaded from database).\nEvery entity is required to have a primary key."),(0,i.kt)("p",null,"Entities can be defined in two ways:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},"Decorated classes - the attributes of the entity, as well as each property are provided\nvia decorators. We use ",(0,i.kt)("inlineCode",{parentName:"li"},"@Entity()")," decorator on the class. Entity properties are decorated\neither with ",(0,i.kt)("inlineCode",{parentName:"li"},"@Property")," decorator, or with one of reference decorators:\n",(0,i.kt)("inlineCode",{parentName:"li"},"@ManyToOne"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"@OneToMany"),", ",(0,i.kt)("inlineCode",{parentName:"li"},"@OneToOne")," and ",(0,i.kt)("inlineCode",{parentName:"li"},"@ManyToMany"),".\nCheck out the full ",(0,i.kt)("a",{parentName:"li",href:"/docs/next/decorators"},"decorator reference"),"."),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"EntitySchema")," helper - With ",(0,i.kt)("inlineCode",{parentName:"li"},"EntitySchema")," helper we define the schema programmatically.\nWe can use regular classes as well as interfaces. This approach also allows to re-use\npartial entity definitions (e.g. traits/mixins). Read more about this\nin ",(0,i.kt)("a",{parentName:"li",href:"/docs/next/entity-schema"},"Defining Entities via EntitySchema section"),".")),(0,i.kt)("p",null,"Moreover, how the metadata extraction from decorators happens is controlled\nvia ",(0,i.kt)("inlineCode",{parentName:"p"},"MetadataProvider"),". Two main metadata providers are:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"ReflectMetadataProvider")," - uses ",(0,i.kt)("inlineCode",{parentName:"li"},"reflect-metadata")," to read the property types. Faster\nbut simpler and more verbose. "),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("inlineCode",{parentName:"li"},"TsMorphMetadataProvider")," - uses ",(0,i.kt)("inlineCode",{parentName:"li"},"ts-morph")," to read the type information from the\nTypeScript compiled API. Heavier (requires full TS as a dependency), but allows DRY\nentity definition. With ",(0,i.kt)("inlineCode",{parentName:"li"},"ts-morph")," we are able to extract the type as it is defined in\nthe code, including interface names, as well as optionality of properties. ")),(0,i.kt)("p",null,"Read more about them in the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/metadata-providers"},"Metadata Providers section"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Current set of decorators in MikroORM is designed to work with the ",(0,i.kt)("inlineCode",{parentName:"p"},"tsc"),".\nUsing ",(0,i.kt)("inlineCode",{parentName:"p"},"babel")," is also possible, but requires some additional setup. Read more about it\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/usage-with-babel"},"here"),". For notes about ",(0,i.kt)("inlineCode",{parentName:"p"},"webpack"),", read the ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/deployment"},"deployment section"),"."),(0,i.kt)("p",{parentName:"blockquote"},(0,i.kt)("inlineCode",{parentName:"p"},"ts-morph")," is compatible only with the ",(0,i.kt)("inlineCode",{parentName:"p"},"tsc")," approach.")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"From v3 we can also use default exports when defining your entity.")),(0,i.kt)("p",null,"Example definition of a ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," entity follows. We can switch the tabs to see the difference\nfor various ways:"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book extends CustomBaseEntity {\n\n  @Property()\n  title!: string;\n\n  @ManyToOne(() => Author)\n  author!: Author;\n\n  @ManyToOne(() => Publisher, { wrappedReference: true, nullable: true })\n  publisher?: IdentifiedReference<Publisher>;\n\n  @ManyToMany({ entity: 'BookTag', fixedOrder: true })\n  tags = new Collection<BookTag>(this);\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book extends CustomBaseEntity {\n\n  @Property()\n  title!: string;\n\n  @ManyToOne()\n  author!: Author;\n\n  @ManyToOne()\n  publisher?: IdentifiedReference<Publisher>;\n\n  @ManyToMany({ fixedOrder: true })\n  tags = new Collection<BookTag>(this);\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export interface IBook extends CustomBaseEntity {\n  title: string;\n  author: Author;\n  publisher?: IdentifiedReference<Publisher>;\n  tags: Collection<BookTag>;\n}\n\nexport const Book = new EntitySchema<IBook, CustomBaseEntity>({\n  name: 'Book',\n  extends: 'CustomBaseEntity',\n  properties: {\n    title: { type: 'string' },\n    author: { reference: 'm:1', entity: 'Author' },\n    publisher: { reference: 'm:1', entity: 'Publisher', wrappedReference: true, nullable: true },\n    tags: { reference: 'm:n', entity: 'BookTag', fixedOrder: true },\n  },\n});\n")))),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Including ",(0,i.kt)("inlineCode",{parentName:"p"},"{ wrappedEntity: true }")," in your ",(0,i.kt)("inlineCode",{parentName:"p"},"IdentifiedReference")," property definitions will wrap the reference, providing access to helper methods like ",(0,i.kt)("inlineCode",{parentName:"p"},".load")," and ",(0,i.kt)("inlineCode",{parentName:"p"},".unwrap"),", which can be helpful for loading data and changing the type of your references where you plan to use them.")),(0,i.kt)("p",null,"Here is another example of ",(0,i.kt)("inlineCode",{parentName:"p"},"Author")," entity, that was referenced from the ",(0,i.kt)("inlineCode",{parentName:"p"},"Book")," one, this\ntime defined for mongo:"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Entity()\nexport class Author {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string;\n\n  @Property()\n  createdAt: Date = new Date();\n\n  @Property({ onUpdate: () => new Date() })\n  updatedAt: Date = new Date();\n\n  @Property()\n  name!: string;\n\n  @Property()\n  email!: string;\n\n  @Property({ nullable: true })\n  age?: number;\n\n  @Property()\n  termsAccepted: boolean = false;\n\n  @Property({ nullable: true })\n  identities?: string[];\n\n  @Property({ nullable: true })\n  born?: Date;\n\n  @OneToMany(() => Book, book => book.author)\n  books = new Collection<Book>(this);\n\n  @ManyToMany(() => Author)\n  friends = new Collection<Author>(this);\n\n  @ManyToOne(() => Book, { nullable: true })\n  favouriteBook?: Book;\n\n  @Property({ version: true })\n  version!: number;\n\n  constructor(name: string, email: string) {\n    this.name = name;\n    this.email = email;\n  }\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Entity()\nexport class Author {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string;\n\n  @Property()\n  createdAt = new Date();\n\n  @Property({ onUpdate: () => new Date() })\n  updatedAt = new Date();\n\n  @Property()\n  name!: string;\n\n  @Property()\n  email!: string;\n\n  @Property()\n  age?: number;\n\n  @Property()\n  termsAccepted = false;\n\n  @Property()\n  identities?: string[];\n\n  @Property()\n  born?: Date;\n\n  @OneToMany(() => Book, book => book.author)\n  books = new Collection<Book>(this);\n\n  @ManyToMany()\n  friends = new Collection<Author>(this);\n\n  @ManyToOne()\n  favouriteBook?: Book;\n\n  @Property({ version: true })\n  version!: number;\n\n  constructor(name: string, email: string) {\n    this.name = name;\n    this.email = email;\n  }\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"export class Author {\n\n  _id!: ObjectId;\n  id!: string;\n  createdAt = new Date();\n  updatedAt = new Date();\n  name!: string;\n  email!: string;\n  age?: number;\n  termsAccepted = false;\n  identities?: string[];\n  born?: Date;\n  books = new Collection<Book>(this);\n  friends = new Collection<Author>(this);\n  favouriteBook?: Book;\n  version!: number;\n\n  constructor(name: string, email: string) {\n    this.name = name;\n    this.email = email;\n  }\n\n}\n\nexport const AuthorSchema = new EntitySchema<Author>({\n  class: Author,\n  properties: {\n    _id: { type: 'ObjectId', primary: true },\n    id: { type: String, serializedPrimaryKey: true },\n    createdAt: { type: Date },\n    updatedAt: { type: Date, onUpdate: () => new Date() },\n    name: { type: String },\n    email: { type: String },\n    age: { type: Number, nullable: true },\n    termsAccepted: { type: Boolean }\n    identities: { type: 'string[]', nullable: true }\n    born: { type: Date, nullable: true }\n    books: { reference: '1:m', entity: () => Book, mappedBy: book => book.author }\n    friends: { reference: 'm:n', entity: () => Author }\n    favouriteBook: { reference: 'm:1', entity: () => Book, nullable: true };\n    version: { type: Number, version: true };\n  },\n});\n")))),(0,i.kt)("p",null,"More information about modelling relationships can be found on ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/relationships"},"modelling relationships page"),"."),(0,i.kt)("p",null,"For an example of Vanilla JavaScript usage, take a look ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/usage-with-js"},"here"),"."),(0,i.kt)("h2",{id:"optional-properties"},"Optional Properties"),(0,i.kt)("p",null,"With the default ",(0,i.kt)("inlineCode",{parentName:"p"},"reflect-metadata")," provider, we need to mark each optional property as ",(0,i.kt)("inlineCode",{parentName:"p"},"nullable: true"),".\nWhen using ",(0,i.kt)("inlineCode",{parentName:"p"},"ts-morph"),", if you define the property as optional (marked with ",(0,i.kt)("inlineCode",{parentName:"p"},"?"),"), this will be automatically considered\nas nullable property (mainly for SQL schema generator)."),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@ManyToOne(() => Book, { nullable: true })\nfavouriteBook?: Book;\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@ManyToOne()\nfavouriteBook?: Book;\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"properties: {\n  favouriteBook: { reference: 'm:1', entity: () => Book, nullable: true },\n},\n")))),(0,i.kt)("h2",{id:"default-values"},"Default values"),(0,i.kt)("p",null,"We can set default value of a property in 2 ways:"),(0,i.kt)("ol",null,(0,i.kt)("li",{parentName:"ol"},"Use runtime default value of the property. This approach should be preferred as long\nas we are not using any native database function like ",(0,i.kt)("inlineCode",{parentName:"li"},"now()"),". With this approach our\nentities will have the default value set even before it is actually persisted into the\ndatabase (e.g. when we instantiate new entity via ",(0,i.kt)("inlineCode",{parentName:"li"},"new Author()")," or ",(0,i.kt)("inlineCode",{parentName:"li"},"em.create(Author, { ... })"),".")),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Property()\nfoo: number = 1;\n\n@Property()\nbar: string = 'abc';\n\n@Property()\nbaz: Date = new Date();\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Property()\nfoo = 1;\n\n@Property()\nbar = 'abc';\n\n@Property()\nbaz = new Date();\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"properties: {\n  foo: { type: Number, onCreate: () => 1 },\n  bar: { type: String, onCreate: () => 'abc' },\n  baz: { type: Date, onCreate: () => new Date() },\n},\n")))),(0,i.kt)("ol",{start:2},(0,i.kt)("li",{parentName:"ol"},(0,i.kt)("p",{parentName:"li"},"Use ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," parameter of ",(0,i.kt)("inlineCode",{parentName:"p"},"@Property")," decorator. This way the actual default value\nwill be provided by the database, and automatically mapped to the entity property after\nit is being persisted (after flush). To use SQL functions like ",(0,i.kt)("inlineCode",{parentName:"p"},"now()"),", use ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultRaw"),"."),(0,i.kt)("blockquote",{parentName:"li"},(0,i.kt)("p",{parentName:"blockquote"},"Since v4 you should use ",(0,i.kt)("inlineCode",{parentName:"p"},"defaultRaw")," for SQL functions, as ",(0,i.kt)("inlineCode",{parentName:"p"},"default")," with string values\nwill be automatically quoted.")))),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Property({ default: 1 })\nfoo!: number;\n\n@Property({ default: 'abc' })\nbar!: string;\n\n@Property({ defaultRaw: 'now' })\nbaz!: Date;\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Property({ default: 1 })\nfoo!: number;\n\n@Property({ default: 'abc' })\nbar!: string;\n\n@Property({ defaultRaw: 'now' })\nbaz!: Date;\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"properties: {\n  foo: { type: Number, default: 1 },\n  bar: { type: String, default: 'abc' },\n  baz: { type: Date, defaultRaw: 'now' },\n},\n")))),(0,i.kt)("h2",{id:"enums"},"Enums"),(0,i.kt)("p",null,"To define enum property, use ",(0,i.kt)("inlineCode",{parentName:"p"},"@Enum()")," decorator. Enums can be either numeric or string valued."),(0,i.kt)("p",null,"For schema generator to work properly in case of string enums, we need to define the enum\nis same file as where it is used, so its values can be automatically discovered. If we want\nto define the enum in another file, we should reexport it also in place where we use it."),(0,i.kt)("p",null,"Another possibility is to provide the reference to the enum implementation in the decorator\nvia ",(0,i.kt)("inlineCode",{parentName:"p"},"@Enum(() => UserRole)"),"."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"We can also set enum items manually via ",(0,i.kt)("inlineCode",{parentName:"p"},"items: string[]")," attribute.")),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"import { OutsideEnum } from './OutsideEnum.ts';\n\n@Entity()\nexport class User {\n\n  @Enum(() => UserRole)\n  role!: UserRole; // string enum\n\n  @Enum(() => UserStatus)\n  status!: UserStatus; // numeric/const enum\n\n  @Enum(() => OutsideEnum)\n  outside!: OutsideEnum; // string enum defined outside of this file\n\n  @Enum({ items: () => OutsideNullableEnum, nullable: true })\n  outsideNullable?: OutsideNullableEnum; // string enum defined outside of this file, may be null\n\n}\n\nexport enum UserRole {\n  ADMIN = 'admin',\n  MODERATOR = 'moderator',\n  USER = 'user',\n}\n\nexport const enum UserStatus {\n  DISABLED,\n  ACTIVE,\n}\n\n// or we could reexport OutsideEnum\n// export { OutsideEnum } from './OutsideEnum.ts';\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"import { OutsideEnum } from './OutsideEnum.ts';\n\n@Entity()\nexport class User {\n\n  @Enum(() => UserRole)\n  role!: UserRole; // string enum\n\n  @Enum(() => UserStatus)\n  status!: UserStatus; // numeric enum\n\n  @Enum(() => OutsideEnum)\n  outside!: OutsideEnum; // string enum defined outside of this file\n\n  @Enum({ items: () => OutsideNullableEnum })\n  outsideNullable?: OutsideNullableEnum; // string enum defined outside of this file, may be null\n\n}\n\nexport enum UserRole {\n  ADMIN = 'admin',\n  MODERATOR = 'moderator',\n  USER = 'user',\n}\n\nexport const enum UserStatus {\n  DISABLED,\n  ACTIVE,\n}\n\n// or we could reexport OutsideEnum\n// export { OutsideEnum } from './OutsideEnum.ts';\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"properties: {\n  // string enum\n  role: { enum: true, items: () => UserRole },\n  // numeric enum\n  status: { enum: true, items: () => UserStatus },\n  // string enum defined outside of this file\n  outside: { enum: true, items: () => OutsideEnum },\n  // string enum defined outside of this file, may be null\n  outsideNullable: { enum: true, items: () => OutsideNullableEnum, nullable: true },\n},\n")))),(0,i.kt)("h2",{id:"enum-arrays"},"Enum arrays"),(0,i.kt)("p",null,"We can also use array of values for enum, in that case, ",(0,i.kt)("inlineCode",{parentName:"p"},"EnumArrayType")," type\nwill be used automatically, that will validate items on flush."),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"enum Role {\n  User = 'user',\n  Admin = 'admin',\n}\n\n@Enum({ items: () => Role, array: true, default: [Role.User] })\nroles: Role[] = [Role.User];\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"enum Role {\n  User = 'user',\n  Admin = 'admin',\n}\n\n@Enum({ default: [Role.User] })\nroles = [Role.User];\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"enum Role {\n  User = 'user',\n  Admin = 'admin',\n}\n\nproperties: {\n  roles: { enum: true, array: true, default: [Role.User], items: () => Role },\n},\n")))),(0,i.kt)("h2",{id:"mapping-directly-to-primary-keys"},"Mapping directly to primary keys"),(0,i.kt)("p",null,"Sometimes we might want to work only with the primary key of a relation.\nTo do that, we can use ",(0,i.kt)("inlineCode",{parentName:"p"},"mapToPk")," option on M:1 and 1:1 relations:"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"@ManyToOne(() => User, { mapToPk: true })\nuser: number;\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"@ManyToOne(() => User, { mapToPk: true })\nuser: number;\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"properties: {\n  user: { entity: () => User, mapToPk: true },\n},\n")))),(0,i.kt)("p",null,"For composite keys, this will give us ordered tuple representing the raw PKs,\nwhich is the internal format of composite PK:"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"@ManyToOne(() => User, { mapToPk: true })\nuser: [string, string]; // [first_name, last_name]\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"@ManyToOne(() => User, { mapToPk: true })\nuser: [string, string]; // [first_name, last_name]\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"properties: {\n  user: { entity: () => User, mapToPk: true },\n},\n")))),"```",(0,i.kt)("h2",{id:"formulas"},"Formulas"),(0,i.kt)("p",null,(0,i.kt)("inlineCode",{parentName:"p"},"@Formula()")," decorator can be used to map some SQL snippet to your entity.\nThe SQL fragment can be as complex as you want and even include subselects."),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Box.ts"',title:'"./entities/Box.ts"'},"@Formula('obj_length * obj_height * obj_width')\nobjectVolume?: number;\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Box.ts"',title:'"./entities/Box.ts"'},"@Formula('obj_length * obj_height * obj_width')\nobjectVolume?: number;\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Box.ts"',title:'"./entities/Box.ts"'},"properties: {\n  objectVolume: { formula: 'obj_length * obj_height * obj_width' },\n},\n")))),"```",(0,i.kt)("p",null,"Formulas will be added to the select clause automatically. In case you are facing\nproblems with ",(0,i.kt)("inlineCode",{parentName:"p"},"NonUniqueFieldNameException"),", you can define the formula as a\ncallback that will receive the entity alias in the parameter:"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Box.ts"',title:'"./entities/Box.ts"'},"@Formula(alias => `${alias}.obj_length * ${alias}.obj_height * ${alias}.obj_width`)\nobjectVolume?: number;\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Box.ts"',title:'"./entities/Box.ts"'},"@Formula(alias => `${alias}.obj_length * ${alias}.obj_height * ${alias}.obj_width`)\nobjectVolume?: number;\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Box.ts"',title:'"./entities/Box.ts"'},"properties: {\n  objectVolume: { formula: alias => `${alias}.obj_length * ${alias}.obj_height * ${alias}.obj_width` },\n},\n")))),(0,i.kt)("h2",{id:"indexes"},"Indexes"),(0,i.kt)("p",null,"We can define indexes via ",(0,i.kt)("inlineCode",{parentName:"p"},"@Index()")," decorator, for unique indexes, we can\nuse ",(0,i.kt)("inlineCode",{parentName:"p"},"@Unique()")," decorator. We can use it either on entity class, or on entity property. "),(0,i.kt)("p",null,"To define complex indexes, we can use index expressions. They allow us to specify the final ",(0,i.kt)("inlineCode",{parentName:"p"},"create index")," query and an index name - this name is then used for index diffing, so the schema generator will only try to create it if it's not there yet, or remove it, if it's no longer defined in the entity. Index expressions are not bound to any property, rather to the entity itself (we can still define them on both entity and property level)."),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Entity()\n@Index({ properties: ['name', 'age'] }) // compound index, with generated name\n@Index({ name: 'custom_idx_name', properties: ['name'] }) // simple index, with custom name\n@Unique({ properties: ['name', 'email'] })\nexport class Author {\n\n  @Property()\n  @Unique()\n  email!: string;\n\n  @Property()\n  @Index() // generated name\n  age?: number;\n\n  @Index({ name: 'born_index' })\n  @Property()\n  born?: Date;\n\n  @Index({ name: 'custom_index_expr', expression: 'alter table `author` add index `custom_index_expr`(`title`)' })\n  @Property()\n  title!: string;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"@Entity()\n@Index({ properties: ['name', 'age'] }) // compound index, with generated name\n@Index({ name: 'custom_idx_name', properties: ['name'] }) // simple index, with custom name\n@Unique({ properties: ['name', 'email'] })\nexport class Author {\n\n  @Property()\n  @Unique()\n  email!: string;\n\n  @Property()\n  @Index() // generated name\n  age?: number;\n\n  @Index({ name: 'born_index' })\n  @Property()\n  born?: Date;\n\n  @Index({ name: 'custom_index_expr', expression: 'alter table `author` add index `custom_index_expr`(`title`)' })\n  @Property()\n  title!: string;\n\n}\n\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Author.ts"',title:'"./entities/Author.ts"'},"export const AuthorSchema = new EntitySchema<Author, CustomBaseEntity>({\n  class: Author,\n  indexes: [\n    { properties: ['name', 'age'] }, // compound index, with generated name\n    { name: 'custom_idx_name', properties: ['name'] }, // simple index, with custom name\n    { name: 'custom_index_expr', expression: 'alter table `author` add index `custom_index_expr`(`title`)' },\n  ],\n  uniques: [\n    { properties: ['name', 'email'] },\n  ],\n  properties: {\n    email: { type: 'string', unique: true }, // generated name\n    age: { type: 'number', nullable: true, index: true }, // generated name\n    born: { type: Date, nullable: true, index: 'born_index' },\n    title: { type: 'string' },\n  },\n});\n")))),(0,i.kt)("h2",{id:"check-constraints"},"Check constraints"),(0,i.kt)("p",null,"We can define check constraints via ",(0,i.kt)("inlineCode",{parentName:"p"},"@Check()")," decorator. We can use it\neither on entity class, or on entity property. It has a required ",(0,i.kt)("inlineCode",{parentName:"p"},"expression"),"\nproperty, that can be either a string or a callback, that receives map of\nproperty names to column names. Note that we need to use the generic type\nargument if we want TypeScript suggestions for the property names."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Check constraints are currently supported only in postgres driver.")),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\n// with generated name based on the table name \n@Check({ expression: 'price1 >= 0' })\n// with explicit name \n@Check({ name: 'foo', expression: columns => `${columns.price1} >= 0` })\n// with explicit type argument we get autocomplete on `columns` \n@Check<FooEntity>({ expression: columns => `${columns.price1} >= 0` })\nexport class Book {\n\n  @PrimaryKey()\n  id!: number;\n\n  @Property()\n  price1!: number;\n\n  @Property()\n  @Check({ expression: 'price2 >= 0' })\n  price2!: number;\n\n  @Property({ check: columns => `${columns.price3} >= 0` })\n  price3!: number;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\n// with generated name based on the table name \n@Check({ expression: 'price1 >= 0' })\n// with explicit name \n@Check({ name: 'foo', expression: columns => `${columns.price1} >= 0` })\n// with explicit type argument we get autocomplete on `columns` \n@Check<FooEntity>({ expression: columns => `${columns.price1} >= 0` })\nexport class Book {\n\n  @PrimaryKey()\n  id!: number;\n\n  @Property()\n  price1!: number;\n\n  @Property()\n  @Check({ expression: 'price2 >= 0' })\n  price2!: number;\n\n  @Property({ check: columns => `${columns.price3} >= 0` })\n  price3!: number;\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export const BookSchema = new EntitySchema<Book>({\n  class: Book,\n  checks: [\n    { expression: 'price1 >= 0' },\n    { name: 'foo', expression: columns => `${columns.price1} >= 0` },\n    { expression: columns => `${columns.price1} >= 0` },\n    { propertyName: 'price2', expression: 'price2 >= 0' },\n    { propertyName: 'price3', expression: columns => `${columns.price3} >= 0` },\n  ],\n  properties: {\n    id: { type: 'number', primary: true },\n    price1: { type: 'number' },\n    price2: { type: 'number' },\n    price3: { type: 'number' },\n  },\n});\n")))),(0,i.kt)("h2",{id:"custom-types"},"Custom Types"),(0,i.kt)("p",null,"We can define custom types by extending ",(0,i.kt)("inlineCode",{parentName:"p"},"Type")," abstract class. It has 4 optional methods:"),(0,i.kt)("ul",null,(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"convertToDatabaseValue(value: any, platform: Platform): any")),(0,i.kt)("p",{parentName:"li"},"Converts a value from its JS representation to its database representation of this type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"convertToJSValue(value: any, platform: Platform): any")),(0,i.kt)("p",{parentName:"li"},"Converts a value from its database representation to its JS representation of this type.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"toJSON(value: any, platform: Platform): any")),(0,i.kt)("p",{parentName:"li"},"Converts a value from its JS representation to its serialized JSON form of this type.\nBy default converts to the database value.")),(0,i.kt)("li",{parentName:"ul"},(0,i.kt)("p",{parentName:"li"},(0,i.kt)("inlineCode",{parentName:"p"},"getColumnType(prop: EntityProperty, platform: Platform): string")),(0,i.kt)("p",{parentName:"li"},"Gets the SQL declaration snippet for a field of this type."))),(0,i.kt)("p",null,"More information can be found in ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/custom-types"},"Custom Types")," section."),(0,i.kt)("h2",{id:"lazy-scalar-properties"},"Lazy scalar properties"),(0,i.kt)("p",null,"We can mark any property as ",(0,i.kt)("inlineCode",{parentName:"p"},"lazy: true")," to omit it from the select clause.\nThis can be handy for properties that are too large, and you want to have them\navailable only sometimes, like a full text of an article."),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Property({ columnType: 'text', lazy: true })\ntext: string;\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Property({ columnType: 'text', lazy: true })\ntext: string;\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"properties: {\n  text: { columnType: 'text', lazy: true },\n}\n")))),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"populate")," parameter to load them."),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const b1 = await em.find(Book, 1); // this will omit the `text` property\nconst b2 = await em.find(Book, 1, { populate: ['text'] }); // this will load the `text` property\n")),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If the entity is already loaded and you need to populate a lazy scalar property,\nyou might need to pass ",(0,i.kt)("inlineCode",{parentName:"p"},"refresh: true")," in the ",(0,i.kt)("inlineCode",{parentName:"p"},"FindOptions"),".")),(0,i.kt)("h2",{id:"virtual-properties"},"Virtual Properties"),(0,i.kt)("p",null,"We can define our properties as virtual, either as a method, or via JavaScript ",(0,i.kt)("inlineCode",{parentName:"p"},"get/set"),"."),(0,i.kt)("p",null,"Following example defines User entity with ",(0,i.kt)("inlineCode",{parentName:"p"},"firstName")," and ",(0,i.kt)("inlineCode",{parentName:"p"},"lastName")," database fields, that\nare both hidden from the serialized response, replaced with virtual properties ",(0,i.kt)("inlineCode",{parentName:"p"},"fullName"),"\n(defined as a classic method) and ",(0,i.kt)("inlineCode",{parentName:"p"},"fullName2")," (defined as a JavaScript getter)."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"For JavaScript getter you need to provide ",(0,i.kt)("inlineCode",{parentName:"p"},"{ persist: false }")," option otherwise the value\nwould be stored in the database.")),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"@Entity()\nexport class User {\n\n  @Property({ hidden: true })\n  firstName!: string;\n\n  @Property({ hidden: true })\n  lastName!: string;\n\n  @Property({ name: 'fullName' })\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  @Property({ persist: false })\n  get fullName2() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"@Entity()\nexport class User {\n\n  @Property({ hidden: true })\n  firstName!: string;\n\n  @Property({ hidden: true })\n  lastName!: string;\n\n  @Property({ name: 'fullName' })\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  @Property({ persist: false })\n  get fullName2() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/User.ts"',title:'"./entities/User.ts"'},"export class User {\n  firstName!: string;\n  lastName!: string;\n\n  getFullName() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n\n  get fullName2() {\n    return `${this.firstName} ${this.lastName}`;\n  }\n}\n\nproperties: {\n  firstName: { type: String, hidden: true },\n  lastName: { type: String, hidden: true },\n  fullName: { type: 'method', persist: false, getter: true, getterName: 'getFullName' },\n  fullName2: { type: 'method', persist: false, getter: true },\n}\n")))),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"const repo = em.getRepository(User);\nconst author = repo.create({ firstName: 'Jon', lastName: 'Snow' });\n\nconsole.log(author.getFullName()); // 'Jon Snow'\nconsole.log(author.fullName2); // 'Jon Snow'\nconsole.log(wrap(author).toJSON()); // { fullName: 'Jon Snow', fullName2: 'Jon Snow' }\n")),(0,i.kt)("h2",{id:"entity-file-names"},"Entity file names"),(0,i.kt)("p",null,"Starting with MikroORM 4.2, there is no limitation for entity file names. It is now\nalso possible to define multiple entities in a single file using folder based discovery."),(0,i.kt)("h2",{id:"using-custom-base-entity"},"Using custom base entity"),(0,i.kt)("p",null,"We can define our own base entity with properties that are required on all entities, like\nprimary key and created/updated time. Single table inheritance is also supported."),(0,i.kt)("p",null,"Read more about this topic in ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/inheritance-mapping"},"Inheritance Mapping")," section."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"If you are initializing the ORM via ",(0,i.kt)("inlineCode",{parentName:"p"},"entities")," option, you need to specify all your\nbase entities as well.")),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/CustomBaseEntity.ts"',title:'"./entities/CustomBaseEntity.ts"'},"import { v4 } from 'uuid';\n\nexport abstract class CustomBaseEntity {\n\n  @PrimaryKey()\n  uuid: string = v4();\n\n  @Property()\n  createdAt: Date = new Date();\n\n  @Property({ onUpdate: () => new Date() })\n  updatedAt: Date = new Date();\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/CustomBaseEntity.ts"',title:'"./entities/CustomBaseEntity.ts"'},"import { v4 } from 'uuid';\n\nexport abstract class CustomBaseEntity {\n\n  @PrimaryKey()\n  uuid = v4();\n\n  @Property()\n  createdAt = new Date();\n\n  @Property({ onUpdate: () => new Date() })\n  updatedAt = new Date();\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/CustomBaseEntity.ts"',title:'"./entities/CustomBaseEntity.ts"'},"import { v4 } from 'uuid';\n\nexport interface CustomBaseEntity {\n  uuid: string;\n  createdAt: Date;\n  updatedAt: Date;\n}\n\nexport const schema = new EntitySchema<CustomBaseEntity>({\n  name: 'CustomBaseEntity',\n  abstract: true,\n  properties: {\n    uuid: { type: 'uuid', onCreate: () => v4(), primary: true },\n    createdAt: { type: 'Date', onCreate: () => new Date(), nullable: true },\n    updatedAt: { type: 'Date', onCreate: () => new Date(), onUpdate: () => new Date(), nullable: true },\n  },\n});\n")))),(0,i.kt)("p",null,"There is a special case, when we need to annotate the base entity - if we are using\nfolder based discovery, and the base entity is not using any decorators (e.g. it does\nnot define any decorated property). In that case, we need to mark it as abstract:"),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"@Entity({ abstract: true })\nexport abstract class CustomBaseEntity {\n  // ...\n}\n")),(0,i.kt)("h2",{id:"examples-of-entity-definition-with-various-primary-keys"},"Examples of entity definition with various primary keys"),(0,i.kt)("h3",{id:"using-id-as-primary-key-sql-drivers"},"Using id as primary key (SQL drivers)"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  id!: number; // string is also supported\n\n  @Property()\n  title!: string;\n\n  @ManyToOne(() => Author)\n  author!: Author;\n\n  @ManyToOne(() => Publisher, { wrappedReference: true, nullable: true })\n  publisher?: IdentifiedReference<Publisher>;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  id!: number; // string is also supported\n\n  @Property()\n  title!: string;\n\n  @ManyToOne()\n  author!: Author;\n\n  @ManyToOne()\n  publisher?: IdentifiedReference<Publisher>;\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export interface Book {\n  id: number;\n  title: string;\n  author: Author;\n}\n\nexport const BookSchema = new EntitySchema<Book>({\n  name: 'Book',\n  properties: {\n    id: { type: Number, primary: true },\n    title: { type: String },\n    author: { reference: 'm:1', entity: 'Author' },\n    publisher: { reference: 'm:1', entity: 'Publisher', wrappedReference: true, nullable: true },\n  },\n});\n")))),(0,i.kt)("h3",{id:"using-uuid-as-primary-key-sql-drivers"},"Using UUID as primary key (SQL drivers)"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"import { v4 } from 'uuid';\n\n@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  uuid: string = v4();\n\n  @Property()\n  title!: string;\n\n  @ManyToOne(() => Author)\n  author!: Author;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"import { v4 } from 'uuid';\n\n@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  uuid = v4();\n\n  @Property()\n  title!: string;\n\n  @ManyToOne()\n  author!: Author;\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export interface IBook {\n  uuid: string;\n  title: string;\n  author: Author;\n}\n\nexport const Book = new EntitySchema<IBook>({\n  name: 'Book',\n  properties: {\n    uuid: { type: 'uuid', onCreate: () => v4(), primary: true },\n    title: { type: 'string' },\n    author: { entity: () => Author, reference: 'm:1' },\n  },\n});\n")))),(0,i.kt)("h3",{id:"using-postgresql-uuid-osp-module-function-as-primary-key"},"Using PostgreSQL ",(0,i.kt)("a",{parentName:"h3",href:"https://www.postgresql.org/docs/current/uuid-ossp.html"},"uuid-osp")," module function as primary key"),(0,i.kt)("p",null,"Requires enabling the module via: ",(0,i.kt)("inlineCode",{parentName:"p"},'create extension "uuid-ossp";')),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey({ type: 'uuid', defaultRaw: 'uuid_generate_v4()' })\n  uuid: string;\n\n  @Property()\n  title!: string;\n\n  @ManyToOne(() => Author)\n  author!: Author;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey({ type: 'uuid', defaultRaw: 'uuid_generate_v4()' })\n  uuid: string;\n\n  @Property()\n  title!: string;\n\n  @ManyToOne()\n  author!: Author;\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export class Book {\n  uuid: string;\n  title!: string;\n  author!: Author;\n}\n\nexport const BookSchema = new EntitySchema<Book>({\n  class: Book,\n  properties: {\n    uuid: { type: 'uuid', defaultRaw: 'uuid_generate_v4()', primary: true },\n    title: { type: 'string' },\n    author: { entity: () => Author, reference: 'm:1' },\n  },\n});\n")))),(0,i.kt)("h3",{id:"using-bigint-as-primary-key-mysql-and-postgresql"},"Using BigInt as primary key (MySQL and PostgreSQL)"),(0,i.kt)("p",null,"We can use ",(0,i.kt)("inlineCode",{parentName:"p"},"BigIntType")," to support ",(0,i.kt)("inlineCode",{parentName:"p"},"bigint"),"s. By default, it will represent the value as\na ",(0,i.kt)("inlineCode",{parentName:"p"},"string"),"."),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/CustomBaseEntity.ts"',title:'"./entities/CustomBaseEntity.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey({ type: BigIntType })\n  id: string;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/CustomBaseEntity.ts"',title:'"./entities/CustomBaseEntity.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey({ type: BigIntType })\n  id: string;\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/CustomBaseEntity.ts"',title:'"./entities/CustomBaseEntity.ts"'},"properties: {\n  id: { type: BigIntType },\n},\n")))),(0,i.kt)("p",null,"If you want to use native ",(0,i.kt)("inlineCode",{parentName:"p"},"bigint"),"s, read the following guide: ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/using-bigint-pks"},"Using native BigInt PKs"),"."),(0,i.kt)("h3",{id:"example-of-mongo-entity"},"Example of Mongo entity"),(0,i.kt)(l.Z,{groupId:"entity-def",defaultValue:"reflect-metadata",values:[{label:"reflect-metadata",value:"reflect-metadata"},{label:"ts-morph",value:"ts-morph"},{label:"EntitySchema",value:"entity-schema"}],mdxType:"Tabs"},(0,i.kt)(s.Z,{value:"reflect-metadata",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string; // string variant of PK, will be handled automatically\n\n  @Property()\n  title!: string;\n\n  @ManyToOne(() => Author)\n  author!: Author;\n\n}\n"))),(0,i.kt)(s.Z,{value:"ts-morph",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"@Entity()\nexport class Book {\n\n  @PrimaryKey()\n  _id!: ObjectId;\n\n  @SerializedPrimaryKey()\n  id!: string; // string variant of PK, will be handled automatically\n\n  @Property()\n  title!: string;\n\n  @ManyToOne()\n  author!: Author;\n\n}\n"))),(0,i.kt)(s.Z,{value:"entity-schema",mdxType:"TabItem"},(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts",metastring:'title="./entities/Book.ts"',title:'"./entities/Book.ts"'},"export interface IBook {\n  _id: ObjectId;\n  id: string;\n  title: string;\n  author: Author;\n}\n\nexport const Book = new EntitySchema<IBook>({\n  name: 'Book',\n  properties: {\n    _id: { type: 'ObjectId', primary: true },\n    id: { type: String, serializedPrimaryKey: true },\n    title: { type: String },\n  },\n});\n")))),(0,i.kt)("h3",{id:"using-mikroorms-baseentity-previously-wrappedentity"},"Using MikroORM's BaseEntity (previously WrappedEntity)"),(0,i.kt)("p",null,"From v4 ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseEntity")," class is provided with ",(0,i.kt)("inlineCode",{parentName:"p"},"init"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"isInitialized"),", ",(0,i.kt)("inlineCode",{parentName:"p"},"assign"),"\nand other methods that are otherwise available via the ",(0,i.kt)("inlineCode",{parentName:"p"},"wrap()")," helper."),(0,i.kt)("blockquote",null,(0,i.kt)("p",{parentName:"blockquote"},"Usage of the ",(0,i.kt)("inlineCode",{parentName:"p"},"BaseEntity")," is optional.")),(0,i.kt)("pre",null,(0,i.kt)("code",{parentName:"pre",className:"language-ts"},"import { BaseEntity } from '@mikro-orm/core';\n\n@Entity()\nexport class Book extends BaseEntity<Book, 'id'> {\n\n  @PrimaryKey()\n  id!: number;\n\n  @Property()\n  title!: string;\n\n  @ManyToOne()\n  author!: Author;\n\n}\n\nconst book = new Book();\nconsole.log(book.isInitialized()); // true\n")),(0,i.kt)("p",null,"Having the entities set up, we can now start ",(0,i.kt)("a",{parentName:"p",href:"/docs/next/entity-manager"},"using entity manager")," and\n",(0,i.kt)("a",{parentName:"p",href:"/docs/next/repositories"},"repositories")," as described in following sections."))}h.isMDXComponent=!0}}]);